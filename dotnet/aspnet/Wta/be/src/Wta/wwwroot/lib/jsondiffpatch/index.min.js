/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/jsondiffpatch@0.6.0/lib/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
class t{constructor(t){this.selfOptions=t||{},this.pipes={}}options(t){return t&&(this.selfOptions=t),this.selfOptions}pipe(t,e){let i=e;if("string"==typeof t){if(void 0===i)return this.pipes[t];this.pipes[t]=i}if(t&&t.name){if(i=t,i.processor===this)return i;this.pipes[i.name]=i}return i.processor=this,i}process(t,e){let i=t;i.options=this.options();let s,n=e||t.pipe||"default";for(;n;)void 0!==i.nextAfterChildren&&(i.next=i.nextAfterChildren,i.nextAfterChildren=null),"string"==typeof n&&(n=this.pipe(n)),n.process(i),s=n,n=null,i&&i.next&&(i=i.next,n=i.pipe||s);return i.hasResult?i.result:void 0}}class e{constructor(t){this.name=t,this.filters=[]}process(t){if(!this.processor)throw new Error("add this pipe to a processor before using it");const e=this.debug,i=this.filters.length,s=t;for(let t=0;t<i;t++){const i=this.filters[t];if(e&&this.log(`filter: ${i.filterName}`),i(s),"object"==typeof s&&s.exiting){s.exiting=!1;break}}!s.next&&this.resultCheck&&this.resultCheck(s)}log(t){console.log(`[jsondiffpatch] ${this.name} pipe, ${t}`)}append(...t){return this.filters.push(...t),this}prepend(...t){return this.filters.unshift(...t),this}indexOf(t){if(!t)throw new Error("a filter name is required");for(let e=0;e<this.filters.length;e++){if(this.filters[e].filterName===t)return e}throw new Error(`filter not found: ${t}`)}list(){return this.filters.map((t=>t.filterName))}after(t,...e){const i=this.indexOf(t);return this.filters.splice(i+1,0,...e),this}before(t,...e){const i=this.indexOf(t);return this.filters.splice(i,0,...e),this}replace(t,...e){const i=this.indexOf(t);return this.filters.splice(i,1,...e),this}remove(t){const e=this.indexOf(t);return this.filters.splice(e,1),this}clear(){return this.filters.length=0,this}shouldHaveResult(t){if(!1!==t){if(!this.resultCheck)return this.resultCheck=t=>{if(!t.hasResult){console.log(t);const e=new Error(`${this.name} failed`);throw e.noResult=!0,e}},this}else this.resultCheck=null}}class i{setResult(t){return this.result=t,this.hasResult=!0,this}exit(){return this.exiting=!0,this}push(t,e){return t.parent=this,void 0!==e&&(t.childName=e),t.root=this.root||this,t.options=t.options||this.options,this.children?(this.children[this.children.length-1].next=t,this.children.push(t)):(this.children=[t],this.nextAfterChildren=this.next||null,this.next=t),t.next=this,this}}function s(t){if("object"!=typeof t)return t;if(null===t)return null;if(Array.isArray(t))return t.map(s);if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp)return function(t){const e=/^\/(.*)\/([gimyu]*)$/.exec(t.toString());return new RegExp(e[1],e[2])}(t);const e={};for(const i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=s(t[i]));return e}class n extends i{constructor(t,e){super(),this.left=t,this.right=e,this.pipe="diff"}setResult(t){if(this.options.cloneDiffValues&&"object"==typeof t){const e="function"==typeof this.options.cloneDiffValues?this.options.cloneDiffValues:s;"object"==typeof t[0]&&(t[0]=e(t[0])),"object"==typeof t[1]&&(t[1]=e(t[1]))}return super.setResult(t)}}class r extends i{constructor(t,e){super(),this.left=t,this.delta=e,this.pipe="patch"}}class o extends i{constructor(t){super(),this.delta=t,this.pipe="reverse"}}const l=function(t){if(t.left!==t.right)if(void 0!==t.left)if(void 0!==t.right){if("function"==typeof t.left||"function"==typeof t.right)throw new Error("functions are not supported");t.leftType=null===t.left?"null":typeof t.left,t.rightType=null===t.right?"null":typeof t.right,t.leftType===t.rightType&&"boolean"!==t.leftType&&"number"!==t.leftType?("object"===t.leftType&&(t.leftIsArray=Array.isArray(t.left)),"object"===t.rightType&&(t.rightIsArray=Array.isArray(t.right)),t.leftIsArray===t.rightIsArray?t.left instanceof RegExp&&(t.right instanceof RegExp?t.setResult([t.left.toString(),t.right.toString()]).exit():t.setResult([t.left,t.right]).exit()):t.setResult([t.left,t.right]).exit()):t.setResult([t.left,t.right]).exit()}else t.setResult([t.left,0,0]).exit();else{if("function"==typeof t.right)throw new Error("functions are not supported");t.setResult([t.right]).exit()}else t.setResult(void 0).exit()};l.filterName="trivial";const f=function(t){if(void 0===t.delta)return void t.setResult(t.left).exit();if(t.nested=!Array.isArray(t.delta),t.nested)return;const e=t.delta;if(1!==e.length)if(2!==e.length)3===e.length&&0===e[2]&&t.setResult(void 0).exit();else{if(t.left instanceof RegExp){const i=/^\/(.*)\/([gimyu]+)$/.exec(e[1]);if(i)return void t.setResult(new RegExp(i[1],i[2])).exit()}t.setResult(e[1]).exit()}else t.setResult(e[0]).exit()};f.filterName="trivial";const c=function(t){if(void 0===t.delta)return void t.setResult(t.delta).exit();if(t.nested=!Array.isArray(t.delta),t.nested)return;const e=t.delta;1!==e.length?2!==e.length?3===e.length&&0===e[2]&&t.setResult([e[0]]).exit():t.setResult([e[1],e[0]]).exit():t.setResult([e[0],0,0]).exit()};c.filterName="trivial";const h=t=>{if(!t||!t.children)return;const e=t.children.length;let i,s=t.result;for(let n=0;n<e;n++)i=t.children[n],void 0!==i.result&&(s=s||{},s[i.childName]=i.result);s&&t.leftIsArray&&(s._t="a"),t.setResult(s).exit()};h.filterName="collectChildren";const u=t=>{if(t.leftIsArray||"object"!==t.leftType)return;const e=t.left,i=t.right;let s,r;const o=t.options.propertyFilter;for(s in e)Object.prototype.hasOwnProperty.call(e,s)&&(o&&!o(s,t)||(r=new n(e[s],i[s]),t.push(r,s)));for(s in i)Object.prototype.hasOwnProperty.call(i,s)&&(o&&!o(s,t)||void 0===e[s]&&(r=new n(void 0,i[s]),t.push(r,s)));t.children&&0!==t.children.length?t.exit():t.setResult(void 0).exit()};u.filterName="objects";const a=function(t){if(!t.nested)return;const e=t.delta;if(e._t)return;const i=e;let s,n;for(s in i)n=new r(t.left[s],i[s]),t.push(n,s);t.exit()};a.filterName="objects";const p=function(t){if(!t||!t.children)return;if(t.delta._t)return;const e=t.left,i=t.children.length;let s;for(let n=0;n<i;n++){s=t.children[n];const i=s.childName;Object.prototype.hasOwnProperty.call(t.left,i)&&void 0===s.result?delete e[i]:e[i]!==s.result&&(e[i]=s.result)}t.setResult(e).exit()};p.filterName="collectChildren";const d=function(t){if(!t.nested)return;if(t.delta._t)return;const e=t.delta;let i,s;for(i in e)s=new o(e[i]),t.push(s,i);t.exit()};d.filterName="objects";const x=t=>{if(!t||!t.children)return;if(t.delta._t)return;const e=t.children.length;let i;const s={};for(let n=0;n<e;n++){i=t.children[n];const e=i.childName;s[e]!==i.result&&(s[e]=i.result)}t.setResult(s).exit()};x.filterName="collectChildren";const g=function(t,e,i,s){return t[i]===e[s]};var y=function(t,e,i,s){const n=s||{},r=function(t,e,i,s){const n=t.length,r=e.length;let o,l;const f=new Array(n+1);for(o=0;o<n+1;o++)for(f[o]=new Array(r+1),l=0;l<r+1;l++)f[o][l]=0;for(f.match=i,o=1;o<n+1;o++)for(l=1;l<r+1;l++)i(t,e,o-1,l-1,s)?f[o][l]=f[o-1][l-1]+1:f[o][l]=Math.max(f[o-1][l],f[o][l-1]);return f}(t,e,i||g,n);return function(t,e,i,s){let n=e.length,r=i.length;const o={sequence:[],indices1:[],indices2:[]};for(;0!==n&&0!==r;)t.match(e,i,n-1,r-1,s)?(o.sequence.unshift(e[n-1]),o.indices1.unshift(n-1),o.indices2.unshift(r-1),--n,--r):t[n][r-1]>t[n-1][r]?--r:--n;return o}(r,t,e,n)};function m(t,e,i,s,n){const r=t[i],o=e[s];if(r===o)return!0;if("object"!=typeof r||"object"!=typeof o)return!1;const l=n.objectHash;if(!l)return n.matchByPosition&&i===s;n.hashCache1=n.hashCache1||[];let f=n.hashCache1[i];if(void 0===f&&(n.hashCache1[i]=f=l(r,i)),void 0===f)return!1;n.hashCache2=n.hashCache2||[];let c=n.hashCache2[s];return void 0===c&&(n.hashCache2[s]=c=l(o,s)),void 0!==c&&f===c}const v=function(t){if(!t.leftIsArray)return;const e={objectHash:t.options&&t.options.objectHash,matchByPosition:t.options&&t.options.matchByPosition};let i,s,r,o=0,l=0;const f=t.left,c=t.right,h=f.length,u=c.length;let a,p;for(h>0&&u>0&&!e.objectHash&&"boolean"!=typeof e.matchByPosition&&(e.matchByPosition=!function(t,e,i,s){for(let n=0;n<i;n++){const i=t[n];for(let t=0;t<s;t++){const s=e[t];if(n!==t&&i===s)return!0}}}(f,c,h,u));o<h&&o<u&&m(f,c,o,o,e);)i=o,a=new n(f[i],c[i]),t.push(a,i),o++;for(;l+o<h&&l+o<u&&m(f,c,h-1-l,u-1-l,e);)s=h-1-l,r=u-1-l,a=new n(f[s],c[r]),t.push(a,r),l++;if(o+l===h){if(h===u)return void t.setResult(void 0).exit();for(p=p||{_t:"a"},i=o;i<u-l;i++)p[i]=[c[i]];return void t.setResult(p).exit()}if(o+l===u){for(p=p||{_t:"a"},i=o;i<h-l;i++)p[`_${i}`]=[f[i],0,0];return void t.setResult(p).exit()}delete e.hashCache1,delete e.hashCache2;const d=f.slice(o,h-l),x=c.slice(o,u-l),g=y(d,x,m,e),v=[];for(p=p||{_t:"a"},i=o;i<h-l;i++)g.indices1.indexOf(i-o)<0&&(p[`_${i}`]=[f[i],0,0],v.push(i));let w=!0;t.options&&t.options.arrays&&!1===t.options.arrays.detectMove&&(w=!1);let R=!1;t.options&&t.options.arrays&&t.options.arrays.includeValueOnMove&&(R=!0);const b=v.length;for(i=o;i<u-l;i++){const l=g.indices2.indexOf(i-o);if(l<0){let l=!1;if(w&&b>0)for(let h=0;h<b;h++)if(s=v[h],m(d,x,s-o,i-o,e)){p[`_${s}`].splice(1,2,i,3),R||(p[`_${s}`][0]=""),r=i,a=new n(f[s],c[r]),t.push(a,r),v.splice(h,1),l=!0;break}l||(p[i]=[c[i]])}else s=g.indices1[l]+o,r=g.indices2[l]+o,a=new n(f[s],c[r]),t.push(a,r)}t.setResult(p).exit()};v.filterName="arrays";const w={numerically:(t,e)=>t-e,numericallyBy:t=>(e,i)=>e[t]-i[t]},R=function(t){if(!t.nested)return;const e=t.delta;if("a"!==e._t)return;let i,s;const n=e,o=t.left;let l=[],f=[];const c=[];for(i in n)if("_t"!==i)if("_"===i[0]){const t=i;if(0!==n[t][2]&&3!==n[t][2])throw new Error(`only removal or move can be applied at original array indices, invalid diff type: ${n[t][2]}`);l.push(parseInt(i.slice(1),10))}else{const t=i;1===n[t].length?f.push({index:parseInt(t,10),value:n[t][0]}):c.push({index:parseInt(t,10),delta:n[t]})}for(l=l.sort(w.numerically),i=l.length-1;i>=0;i--){s=l[i];const t=n[`_${s}`],e=o.splice(s,1)[0];3===t[2]&&f.push({index:t[1],value:e})}f=f.sort(w.numericallyBy("index"));const h=f.length;for(i=0;i<h;i++){const t=f[i];o.splice(t.index,0,t.value)}const u=c.length;let a;if(u>0)for(i=0;i<u;i++){const e=c[i];a=new r(o[e.index],e.delta),t.push(a,e.index)}t.children?t.exit():t.setResult(o).exit()};R.filterName="arrays";const b=function(t){if(!t||!t.children)return;if("a"!==t.delta._t)return;const e=t.left,i=t.children.length;let s;for(let n=0;n<i;n++){s=t.children[n];e[s.childName]=s.result}t.setResult(e).exit()};b.filterName="arraysCollectChildren";const _=function(t){if(!t.nested){const e=t.delta;if(3===e[2]){const i=e;t.newName=`_${i[1]}`,t.setResult([i[0],parseInt(t.childName.substring(1),10),3]).exit()}return}const e=t.delta;if("a"!==e._t)return;const i=e;let s,n;for(s in i)"_t"!==s&&(n=new o(i[s]),t.push(n,s));t.exit()};_.filterName="arrays";const N=(t,e,i)=>{if("string"==typeof e&&"_"===e[0])return parseInt(e.substring(1),10);if(Array.isArray(i)&&0===i[2])return`_${e}`;let s=+e;for(const i in t){const n=t[i];if(Array.isArray(n))if(3===n[2]){const t=parseInt(i.substring(1),10),r=n[1];if(r===+e)return t;t<=s&&r>s?s++:t>=s&&r<s&&s--}else if(0===n[2]){parseInt(i.substring(1),10)<=s&&s++}else 1===n.length&&parseInt(i,10)<=s&&s--}return s},A=t=>{if(!t||!t.children)return;const e=t.delta;if("a"!==e._t)return;const i=e,s=t.children.length;let n;const r={_t:"a"};for(let e=0;e<s;e++){n=t.children[e];let s=n.newName;void 0===s&&(s=N(i,n.childName,n.result)),r[s]!==n.result&&(r[s]=n.result)}t.setResult(r).exit()};A.filterName="arraysCollectChildren";const C=function(t){t.left instanceof Date?(t.right instanceof Date?t.left.getTime()!==t.right.getTime()?t.setResult([t.left,t.right]):t.setResult(void 0):t.setResult([t.left,t.right]),t.exit()):t.right instanceof Date&&t.setResult([t.left,t.right]).exit()};C.filterName="dates";let j=null;function O(t,e){var i;if(!j){let s;if(!(null===(i=null==t?void 0:t.textDiff)||void 0===i?void 0:i.diffMatchPatch)){if(!e)return null;const t=new Error("The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.");throw t.diff_match_patch_not_found=!0,t}s=new t.textDiff.diffMatchPatch,j={diff:function(t,e){return s.patch_toText(s.patch_make(t,e))},patch:function(t,e){const i=s.patch_apply(s.patch_fromText(e),t);for(let t=0;t<i[1].length;t++)if(!i[1][t]){new Error("text patch failed").textPatchFailed=!0}return i[0]}}}return j}const T=function(t){if("string"!==t.leftType)return;const e=t.left,i=t.right,s=t.options&&t.options.textDiff&&t.options.textDiff.minLength||60;if(e.length<s||i.length<s)return void t.setResult([e,i]).exit();const n=O(t.options);if(!n)return void t.setResult([e,i]).exit();const r=n.diff;t.setResult([r(e,i),0,2]).exit()};T.filterName="texts";const $=function(t){if(t.nested)return;const e=t.delta;if(2!==e[2])return;const i=e,s=O(t.options,!0).patch;t.setResult(s(t.left,i[0])).exit()};$.filterName="texts";const E=function(t){let e,i,s,n,r=null;const o=/^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;let l;const f=t.split("\n");for(e=0,i=f.length;e<i;e++){s=f[e];const t=s.slice(0,1);"@"===t?(r=o.exec(s),l=e,f[l]="@@ -"+r[3]+","+r[4]+" +"+r[1]+","+r[2]+" @@"):"+"===t?(f[e]="-"+f[e].slice(1),"+"===f[e-1].slice(0,1)&&(n=f[e],f[e]=f[e-1],f[e-1]=n)):"-"===t&&(f[e]="+"+f[e].slice(1))}return f.join("\n")},I=function(t){if(t.nested)return;const e=t.delta;if(2!==e[2])return;const i=e;t.setResult([E(i[0]),0,2]).exit()};I.filterName="texts";class D{constructor(i){this.processor=new t(i),this.processor.pipe(new e("diff").append(h,l,C,T,u,v).shouldHaveResult()),this.processor.pipe(new e("patch").append(p,b,f,$,a,R).shouldHaveResult()),this.processor.pipe(new e("reverse").append(x,A,c,I,d,_).shouldHaveResult())}options(t){return this.processor.options(t)}diff(t,e){return this.processor.process(new n(t,e))}patch(t,e){return this.processor.process(new r(t,e))}reverse(t){return this.processor.process(new o(t))}unpatch(t,e){return this.patch(t,this.reverse(e))}clone(t){return s(t)}}function P(t,e){let i;return"string"==typeof e&&(i=/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+-])(\d{2}):(\d{2}))$/.exec(e),i)?new Date(Date.UTC(+i[1],+i[2]-1,+i[3],+i[4],+i[5],+i[6],+(i[7]||0))):e}function k(t){return new D(t)}let H;function B(t,e){return H||(H=new D),H.diff(t,e)}function M(t,e){return H||(H=new D),H.patch(t,e)}function V(t,e){return H||(H=new D),H.unpatch(t,e)}function q(t){return H||(H=new D),H.reverse(t)}function S(t){return H||(H=new D),H.clone(t)}export{D as DiffPatcher,S as clone,k as create,P as dateReviver,B as diff,M as patch,q as reverse,V as unpatch};export default null;
//# sourceMappingURL=/sm/fd371c1ee77664b6ad3c815c6aed23031a38f7816e32d8afbdff33935e7e9afd.map